//  Unit Test for nano-float. To run QEMU Emulator for Blue Pill:
//  cd /mnt/c/qemu_stm32 ; arm-softmmu/qemu-system-arm -M stm32-f103c8 -semihosting -kernel /mnt/c/codal-libopencm3/.pioenvs/bluepill_f103c8/firmware.bin
//  cd C:\qemu_stm32 && arm-none-eabi-gdb -ex="target remote localhost:1234" /codal-libopencm3/.pioenvs/bluepill_f103c8/firmware.elf
#ifdef UNIT_TEST
#include <libopencm3/stm32/rcc.h>
#include <libopencm3/stm32/rtc.h>
#include <unity.h>
#include <logger.h>
#include <math.h>
#define M_LN10		2.30258509299404568402  //  Natural log of 10
#define M_PI_2		1.57079632679489661923  //  Pi divided by 2
#define pi (M_PI_2 * 2)

uint8_t *get_float_usage(uint16_t *size);
volatile double x = 0, y = 0, r = 0;
volatile float xf = 0, yf = 0, rf = 0;

void test_aeabi_fdiv(void) {
    //  gcc compiles "x / y" to "__aeabi_fdiv(x, y)"
    xf = 2205.1969; yf = 270.8886; rf = xf / yf; TEST_ASSERT_EQUAL_FLOAT( 8.140604292687105, rf );
}

void test_aeabi_ddiv(void) {
    x = 2205.1969; y = 270.8886; r = x / y; TEST_ASSERT_EQUAL_DOUBLE( 8.140604292687105, r );
}

void test_aeabi_dmul(void) {
    x = 2205.1969; y = 270.8886; r = x * y; TEST_ASSERT_EQUAL_DOUBLE( 597362.70096534, r );
}

void test_sqrt(void) {
//  TODO: TEST_ASSERT_DOUBLE_WITHIN
//  Must use x because compiler will optimise all constants.
//  Autogenerated from https://docs.google.com/spreadsheets/d/1Uogm7SpgWVA4AiP6gqFkluaozFtlaEGMc4K2Mbfee7U/edit#gid=1740497564
x = 100; 	r = sqrt(x); 	TEST_ASSERT_EQUAL_DOUBLE( 10.000000	 , r );
x = 2; 	r = sqrt(x); 	TEST_ASSERT_EQUAL_DOUBLE( 1.414214	 , r );
x = -0; 	r = sqrt(x); 	TEST_ASSERT_EQUAL_DOUBLE( -0.000000	 , r );
// x = -1.0; 	r = sqrt(x); 	TEST_ASSERT_EQUAL_DOUBLE( -nan	 , r );
}

void test_log(void) {
x = 1; 	r = log(x); 	TEST_ASSERT_EQUAL_DOUBLE( 0.000000	 , r );
x = 2; 	r = log(x); 	TEST_ASSERT_EQUAL_DOUBLE( _M_LN2	 , r );
x = 10; 	r = log(x); 	TEST_ASSERT_EQUAL_DOUBLE( M_LN10	 , r );
// x = +Inf; 	r = log(x); 	TEST_ASSERT_EQUAL_DOUBLE( inf	 , r );
// x = 0; 	r = log(x); 	TEST_ASSERT_EQUAL_DOUBLE( -inf	 , r );
}

void test_exp(void) {
x = 1; 	r = exp(x); 	TEST_ASSERT_EQUAL_DOUBLE( 2.718282	 , r );
x = _M_LN2; 	r = exp(x); 	TEST_ASSERT_EQUAL_DOUBLE( 2	 , r );
x = M_LN10; 	r = exp(x); 	TEST_ASSERT_EQUAL_DOUBLE( 10	 , r );
x = -0; 	r = exp(x); 	TEST_ASSERT_EQUAL_DOUBLE( 1.000000	 , r );
// x = -Inf; 	r = exp(x); 	TEST_ASSERT_EQUAL_DOUBLE( 0.000000	 , r );
}

void test_log10(void) {
// x = x; 	r = log10(x); 	TEST_ASSERT_EQUAL_DOUBLE( ln(x) / ln(10)	 , r );
x = 1000; 	r = log10(x); 	TEST_ASSERT_EQUAL_DOUBLE( 3.000000	 , r );
x = 0.001; 	r = log10(x); 	TEST_ASSERT_EQUAL_DOUBLE( -3.000000	 , r );
x = 1; 	r = log10(x); 	TEST_ASSERT_EQUAL_DOUBLE( 0.000000	 , r );
// x = +Inf; 	r = log10(x); 	TEST_ASSERT_EQUAL_DOUBLE( inf	 , r );
// x = 0; 	r = log10(x); 	TEST_ASSERT_EQUAL_DOUBLE( -inf	 , r );
}

void test_pow(void) {
x = 2; 	y = 10; 	r = pow(x, y); 	TEST_ASSERT_EQUAL_DOUBLE( 1024.000000	 , r );
x = 2; 	y = 0.5; 	r = pow(x, y); 	TEST_ASSERT_EQUAL_DOUBLE( 1.414214	 , r );
x = -2; 	y = -3; 	r = pow(x, y); 	TEST_ASSERT_EQUAL_DOUBLE( -0.125000	 , r );
// x = -1; 	y = NAN; 	r = pow(x, y); 	TEST_ASSERT_EQUAL_DOUBLE( nan	 , r );
x = +1; 	y = NAN; 	r = pow(x, y); 	TEST_ASSERT_EQUAL_DOUBLE( 1.000000	 , r );
// x = INFINITY; 	y = 2; 	r = pow(x, y); 	TEST_ASSERT_EQUAL_DOUBLE( inf	 , r );
// x = INFINITY; 	y = -1; 	r = pow(x, y); 	TEST_ASSERT_EQUAL_DOUBLE( 0.000000	 , r );
// x = -1; 	y = 1/3; 	r = pow(x, y); 	TEST_ASSERT_EQUAL_DOUBLE( -nan	 , r );
}

void test_ldexp(void) {
// x = x; 	y = ex; 	r = ldexp(x, y); 	TEST_ASSERT_EQUAL_DOUBLE( x * pow(2, ex)	 , r );
x = 7; 	y = -4; 	r = ldexp(x, y); 	TEST_ASSERT_EQUAL_DOUBLE( 0.437500	 , r );
x = -0; 	y = 10; 	r = ldexp(x, y); 	TEST_ASSERT_EQUAL_DOUBLE( -0.000000	 , r );
// x = -Inf; 	y = -1; 	r = ldexp(x, y); 	TEST_ASSERT_EQUAL_DOUBLE( -inf	 , r );
// x = 1; 	y = 1024; 	r = ldexp(x, y); 	TEST_ASSERT_EQUAL_DOUBLE( inf	 , r );
}

void test_sin(void) {
x = pi/6; 	r = sin(x); 	TEST_ASSERT_EQUAL_DOUBLE( 0.500000	 , r );
x = pi/2; 	r = sin(x); 	TEST_ASSERT_EQUAL_DOUBLE( 1.000000	 , r );
x = -3*pi/4; 	r = sin(x); 	TEST_ASSERT_EQUAL_DOUBLE( -0.707107	 , r );
x = +0; 	r = sin(x); 	TEST_ASSERT_EQUAL_DOUBLE( 0.000000	 , r );
x = -0; 	r = sin(x); 	TEST_ASSERT_EQUAL_DOUBLE( -0.000000	 , r );
// x = INFINITY; 	r = sin(x); 	TEST_ASSERT_EQUAL_DOUBLE( -nan	 , r );
}

void test_cos(void) {
x = pi/3; 	r = cos(x); 	TEST_ASSERT_EQUAL_DOUBLE( 0.500000	 , r );
x = pi/2; 	r = cos(x); 	TEST_ASSERT_EQUAL_DOUBLE( 0.000000	 , r );
x = -3*pi/4; 	r = cos(x); 	TEST_ASSERT_EQUAL_DOUBLE( -0.707107	 , r );
x = +0; 	r = cos(x); 	TEST_ASSERT_EQUAL_DOUBLE( 1.000000	 , r );
x = -0; 	r = cos(x); 	TEST_ASSERT_EQUAL_DOUBLE( 1.000000	 , r );
// x = INFINITY; 	r = cos(x); 	TEST_ASSERT_EQUAL_DOUBLE( -nan	 , r );
}

void test_tan(void) {
x = 3*pi/4; 	r = tan(x); 	TEST_ASSERT_EQUAL_DOUBLE( -1.000000	 , r );
x = 5*pi/4; 	r = tan(x); 	TEST_ASSERT_EQUAL_DOUBLE( +1.000000	 , r );
x = 7*pi/4; 	r = tan(x); 	TEST_ASSERT_EQUAL_DOUBLE( -1.000000	 , r );
x = +0; 	r = tan(x); 	TEST_ASSERT_EQUAL_DOUBLE( 0.000000	 , r );
x = -0; 	r = tan(x); 	TEST_ASSERT_EQUAL_DOUBLE( -0.000000	 , r );
// x = INFINITY; 	r = tan(x); 	TEST_ASSERT_EQUAL_DOUBLE( -nan	 , r );
}

void test_atan2(void) {
x = +1; 	y = +1; 	r = atan2(x, y); 	TEST_ASSERT_EQUAL_DOUBLE( 0.785398	 , r );
x = +1; 	y = -1; 	r = atan2(x, y); 	TEST_ASSERT_EQUAL_DOUBLE( 2.356194	 , r );
x = -1; 	y = -1; 	r = atan2(x, y); 	TEST_ASSERT_EQUAL_DOUBLE( -2.356194	 , r );
x = -1; 	y = +1; 	r = atan2(x, y); 	TEST_ASSERT_EQUAL_DOUBLE( -0.785398	 , r );
x = 0; 	y = 0; 	r = atan2(x, y); 	TEST_ASSERT_EQUAL_DOUBLE( 0.000000	 , r );
x = 0; 	y = -0; 	r = atan2(x, y); 	TEST_ASSERT_EQUAL_DOUBLE( 3.141593	 , r );
x = 7; 	y = 0; 	r = atan2(x, y); 	TEST_ASSERT_EQUAL_DOUBLE( 1.570796	 , r );
x = 7; 	y = -0; 	r = atan2(x, y); 	TEST_ASSERT_EQUAL_DOUBLE( 1.570796	 , r );
}

void test_atan(void) {
x = 1; 	r = atan(x); 	TEST_ASSERT_EQUAL_DOUBLE( 0.785398	 , r );
// x = Inf; 	r = atan(x); 	TEST_ASSERT_EQUAL_DOUBLE( 1.570796	 , r );
x = -0.0; 	r = atan(x); 	TEST_ASSERT_EQUAL_DOUBLE( -0.000000	 , r );
x = +0.0; 	r = atan(x); 	TEST_ASSERT_EQUAL_DOUBLE( +0.000000	 , r );
}

void test_asin(void) {
// x = x; 	r = arcsin(x); 	TEST_ASSERT_EQUAL_DOUBLE( arctan( x / sqrt( 1 - x^2 ) )	 , r );
x =  1.0; 	r = asin(x); 	TEST_ASSERT_EQUAL_DOUBLE( +1.570796	 , r );
x = -0.5; 	r = asin(x); 	TEST_ASSERT_EQUAL_DOUBLE( -0.523599	 , r );
// x = 1.1; 	r = asin(x); 	TEST_ASSERT_EQUAL_DOUBLE( nan	 , r );
}

void test_acos(void) {
// x = x; 	r = arccos(x); 	TEST_ASSERT_EQUAL_DOUBLE( 2 * arctan(	 , r );
x = -1; 	r = acos(x); 	TEST_ASSERT_EQUAL_DOUBLE( 3.141593	 , r );
x = 0.0; 	r = acos(x); 	TEST_ASSERT_EQUAL_DOUBLE( 1.570796	 , r );
x = 0.5; 	r = acos(x); 	TEST_ASSERT_EQUAL_DOUBLE( 1.047198	 , r );
x = 1; 	r = acos(x); 	TEST_ASSERT_EQUAL_DOUBLE( 0.000000	 , r );
// x = 1.1; 	r = acos(x); 	TEST_ASSERT_EQUAL_DOUBLE( nan	 , r );
}

void test_trunc(void) {
x = +2.7; 	r = trunc(x); 	TEST_ASSERT_EQUAL_DOUBLE( +2.0	 , r );
x = -2.7; 	r = trunc(x); 	TEST_ASSERT_EQUAL_DOUBLE( -2.0	 , r );
x = -0.0; 	r = trunc(x); 	TEST_ASSERT_EQUAL_DOUBLE( -0.0	 , r );
}

void test_floor(void) {
x = +2.7; 	r = floor(x); 	TEST_ASSERT_EQUAL_DOUBLE( +2.0	 , r );
x = -2.7; 	r = floor(x); 	TEST_ASSERT_EQUAL_DOUBLE( -3.0	 , r );
x = -0.0; 	r = floor(x); 	TEST_ASSERT_EQUAL_DOUBLE( -0.0	 , r );
}

void test_ceil(void) {
x = +2.4; 	r = ceil(x); 	TEST_ASSERT_EQUAL_DOUBLE( +3.0	 , r );
x = -2.4; 	r = ceil(x); 	TEST_ASSERT_EQUAL_DOUBLE( -2.0	 , r );
x = -0.0; 	r = ceil(x); 	TEST_ASSERT_EQUAL_DOUBLE( -0.0	 , r );
}

void test_fmod(void) {
x = +5.1; 	y = +3.0; 	r = fmod(x, y); 	TEST_ASSERT_EQUAL_DOUBLE( 2.1	 , r );
x = -5.1; 	y = +3.0; 	r = fmod(x, y); 	TEST_ASSERT_EQUAL_DOUBLE( -2.1	 , r );
x = +5.1; 	y = -3.0; 	r = fmod(x, y); 	TEST_ASSERT_EQUAL_DOUBLE( 2.1	 , r );
x = -5.1; 	y = -3.0; 	r = fmod(x, y); 	TEST_ASSERT_EQUAL_DOUBLE( -2.1	 , r );
x = +0.0; 	y = 1.0; 	r = fmod(x, y); 	TEST_ASSERT_EQUAL_DOUBLE( 0.0	 , r );
x = -0.0; 	y = 1.0; 	r = fmod(x, y); 	TEST_ASSERT_EQUAL_DOUBLE( -0.0	 , r );
// x = +5.1; 	y = Inf; 	r = fmod(x, y); 	TEST_ASSERT_EQUAL_DOUBLE( 5.1	 , r );
// x = +5.1; 	y = 0; 	r = fmod(x, y); 	TEST_ASSERT_EQUAL_DOUBLE( nan	 , r );
}

void test_fabs(void) {
x = +3; 	r = fabs(x); 	TEST_ASSERT_EQUAL_DOUBLE( 3.000000	 , r );
x = -3; 	r = fabs(x); 	TEST_ASSERT_EQUAL_DOUBLE( 3.000000	 , r );
x = -0; 	r = fabs(x); 	TEST_ASSERT_EQUAL_DOUBLE( 0.000000	 , r );
// x = -Inf; 	r = fabs(x); 	TEST_ASSERT_EQUAL_DOUBLE( inf	 , r );
}

int test_nanofloat(void) {
    debug_flush();
    UNITY_BEGIN();

    RUN_TEST(test_aeabi_fdiv);
    RUN_TEST(test_aeabi_ddiv);
    RUN_TEST(test_aeabi_dmul);

    RUN_TEST(test_sqrt);
    RUN_TEST(test_log);
    RUN_TEST(test_exp);
    RUN_TEST(test_log10);
    RUN_TEST(test_pow);
    RUN_TEST(test_ldexp);
    RUN_TEST(test_sin);
    RUN_TEST(test_cos);
    RUN_TEST(test_tan);
    RUN_TEST(test_atan2);
    RUN_TEST(test_atan);
    RUN_TEST(test_asin);
    RUN_TEST(test_acos);
    RUN_TEST(test_trunc);
    RUN_TEST(test_floor);
    RUN_TEST(test_ceil);
    RUN_TEST(test_fmod);
    RUN_TEST(test_fabs);

    int fails = UNITY_END(); debug_flush();
    uint16_t size = 0;
    uint8_t *float_usage = get_float_usage(&size);
    if (float_usage != NULL && size < 1000) {
        uint16_t i = 0;
        for (i = 0; i < size; i++) {
            if (float_usage[i] == 0) { continue; }
            debug_printhex(i); debug_print(" > "); 
            debug_printhex(float_usage[i]); debug_print(" / ");
        }
        debug_println(""); debug_flush();
    }
    //  Crash and exit.
    //  rtc_awake_from_off(LSE);
    return fails;
}

void unity_output_char(int ch) {
    debug_write((uint8_t) ch);
}
#endif  //  UNIT_TEST
